// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: annotations.sql

package sqlc

import (
	"context"
	"strings"
	"time"
)

const checkAnnotationExists = `-- name: CheckAnnotationExists :one
SELECT EXISTS (
    SELECT 1
    FROM annotations
    WHERE image_sha256 = ? AND username = ? AND stage_index = ?
)
`

type CheckAnnotationExistsParams struct {
	ImageSha256 string `json:"image_sha256"`
	Username    string `json:"username"`
	StageIndex  int64  `json:"stage_index"`
}

func (q *Queries) CheckAnnotationExists(ctx context.Context, arg CheckAnnotationExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkAnnotationExists, arg.ImageSha256, arg.Username, arg.StageIndex)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const checkAnnotationExistsForImageStage = `-- name: CheckAnnotationExistsForImageStage :one
SELECT EXISTS (
    SELECT 1
    FROM annotations
    WHERE image_sha256 = ? AND stage_index = ?
)
`

type CheckAnnotationExistsForImageStageParams struct {
	ImageSha256 string `json:"image_sha256"`
	StageIndex  int64  `json:"stage_index"`
}

func (q *Queries) CheckAnnotationExistsForImageStage(ctx context.Context, arg CheckAnnotationExistsForImageStageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkAnnotationExistsForImageStage, arg.ImageSha256, arg.StageIndex)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countAnnotationsByUser = `-- name: CountAnnotationsByUser :one
SELECT COUNT(*) FROM annotations
WHERE username = ?
`

func (q *Queries) CountAnnotationsByUser(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAnnotationsByUser, username)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImagesWithAnnotation = `-- name: CountImagesWithAnnotation :one
SELECT COUNT(DISTINCT image_sha256)
FROM annotations
WHERE stage_index = ? AND option_value = ?
`

type CountImagesWithAnnotationParams struct {
	StageIndex  int64  `json:"stage_index"`
	OptionValue string `json:"option_value"`
}

func (q *Queries) CountImagesWithAnnotation(ctx context.Context, arg CountImagesWithAnnotationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countImagesWithAnnotation, arg.StageIndex, arg.OptionValue)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImagesWithAnnotationInList = `-- name: CountImagesWithAnnotationInList :one
SELECT COUNT(DISTINCT image_sha256)
FROM annotations
WHERE stage_index = ? AND option_value = ?
  AND image_sha256 IN (/*SLICE:image_hashes*/?)
`

type CountImagesWithAnnotationInListParams struct {
	StageIndex  int64    `json:"stage_index"`
	OptionValue string   `json:"option_value"`
	ImageHashes []string `json:"image_hashes"`
}

func (q *Queries) CountImagesWithAnnotationInList(ctx context.Context, arg CountImagesWithAnnotationInListParams) (int64, error) {
	query := countImagesWithAnnotationInList
	var queryParams []interface{}
	queryParams = append(queryParams, arg.StageIndex)
	queryParams = append(queryParams, arg.OptionValue)
	if len(arg.ImageHashes) > 0 {
		for _, v := range arg.ImageHashes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:image_hashes*/?", strings.Repeat(",?", len(arg.ImageHashes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:image_hashes*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImagesWithoutAnnotationForStage = `-- name: CountImagesWithoutAnnotationForStage :one
WITH annotated_images AS (
  SELECT DISTINCT image_sha256 FROM annotations WHERE stage_index = ?
)
SELECT COUNT(*)
FROM images i
LEFT JOIN annotated_images ai ON i.sha256 = ai.image_sha256
WHERE ai.image_sha256 IS NULL
`

func (q *Queries) CountImagesWithoutAnnotationForStage(ctx context.Context, stageIndex int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countImagesWithoutAnnotationForStage, stageIndex)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingImagesForUserAndStage = `-- name: CountPendingImagesForUserAndStage :one
WITH annotated_images AS (
  SELECT image_sha256 FROM annotations WHERE username = ? AND stage_index = ?
)
SELECT COUNT(*)
FROM images i
LEFT JOIN annotated_images ai ON i.sha256 = ai.image_sha256
WHERE ai.image_sha256 IS NULL
`

type CountPendingImagesForUserAndStageParams struct {
	Username   string `json:"username"`
	StageIndex int64  `json:"stage_index"`
}

func (q *Queries) CountPendingImagesForUserAndStage(ctx context.Context, arg CountPendingImagesForUserAndStageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingImagesForUserAndStage, arg.Username, arg.StageIndex)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAnnotation = `-- name: CreateAnnotation :one
INSERT INTO annotations (image_sha256, username, stage_index, option_value)
VALUES (?, ?, ?, ?)
ON CONFLICT(image_sha256, username, stage_index)
DO UPDATE SET
  option_value = excluded.option_value,
  annotated_at = CURRENT_TIMESTAMP
RETURNING id, image_sha256, username, stage_index, option_value, annotated_at
`

type CreateAnnotationParams struct {
	ImageSha256 string `json:"image_sha256"`
	Username    string `json:"username"`
	StageIndex  int64  `json:"stage_index"`
	OptionValue string `json:"option_value"`
}

func (q *Queries) CreateAnnotation(ctx context.Context, arg CreateAnnotationParams) (Annotation, error) {
	row := q.db.QueryRowContext(ctx, createAnnotation,
		arg.ImageSha256,
		arg.Username,
		arg.StageIndex,
		arg.OptionValue,
	)
	var i Annotation
	err := row.Scan(
		&i.ID,
		&i.ImageSha256,
		&i.Username,
		&i.StageIndex,
		&i.OptionValue,
		&i.AnnotatedAt,
	)
	return i, err
}

const deleteAnnotation = `-- name: DeleteAnnotation :exec
DELETE FROM annotations
WHERE id = ?
`

func (q *Queries) DeleteAnnotation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAnnotation, id)
	return err
}

const deleteAnnotationsForImage = `-- name: DeleteAnnotationsForImage :exec
DELETE FROM annotations
WHERE image_sha256 = ?
`

func (q *Queries) DeleteAnnotationsForImage(ctx context.Context, imageSha256 string) error {
	_, err := q.db.ExecContext(ctx, deleteAnnotationsForImage, imageSha256)
	return err
}

const getAllImageSHA256s = `-- name: GetAllImageSHA256s :many
SELECT sha256 FROM images ORDER BY sha256
`

func (q *Queries) GetAllImageSHA256s(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllImageSHA256s)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var sha256 string
		if err := rows.Scan(&sha256); err != nil {
			return nil, err
		}
		items = append(items, sha256)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnnotation = `-- name: GetAnnotation :one
SELECT id, image_sha256, username, stage_index, option_value, annotated_at FROM annotations
WHERE image_sha256 = ? AND username = ? AND stage_index = ?
`

type GetAnnotationParams struct {
	ImageSha256 string `json:"image_sha256"`
	Username    string `json:"username"`
	StageIndex  int64  `json:"stage_index"`
}

func (q *Queries) GetAnnotation(ctx context.Context, arg GetAnnotationParams) (Annotation, error) {
	row := q.db.QueryRowContext(ctx, getAnnotation, arg.ImageSha256, arg.Username, arg.StageIndex)
	var i Annotation
	err := row.Scan(
		&i.ID,
		&i.ImageSha256,
		&i.Username,
		&i.StageIndex,
		&i.OptionValue,
		&i.AnnotatedAt,
	)
	return i, err
}

const getAnnotationStats = `-- name: GetAnnotationStats :one
SELECT
  COUNT(DISTINCT image_sha256) as annotated_images,
  COUNT(*) as total_annotations,
  COUNT(DISTINCT username) as total_users
FROM annotations
`

type GetAnnotationStatsRow struct {
	AnnotatedImages  int64 `json:"annotated_images"`
	TotalAnnotations int64 `json:"total_annotations"`
	TotalUsers       int64 `json:"total_users"`
}

func (q *Queries) GetAnnotationStats(ctx context.Context) (GetAnnotationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAnnotationStats)
	var i GetAnnotationStatsRow
	err := row.Scan(&i.AnnotatedImages, &i.TotalAnnotations, &i.TotalUsers)
	return i, err
}

const getAnnotationsByImageAndUser = `-- name: GetAnnotationsByImageAndUser :many
SELECT id, image_sha256, username, stage_index, option_value, annotated_at FROM annotations
WHERE image_sha256 = ? AND username = ?
ORDER BY stage_index ASC
`

type GetAnnotationsByImageAndUserParams struct {
	ImageSha256 string `json:"image_sha256"`
	Username    string `json:"username"`
}

func (q *Queries) GetAnnotationsByImageAndUser(ctx context.Context, arg GetAnnotationsByImageAndUserParams) ([]Annotation, error) {
	rows, err := q.db.QueryContext(ctx, getAnnotationsByImageAndUser, arg.ImageSha256, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Annotation{}
	for rows.Next() {
		var i Annotation
		if err := rows.Scan(
			&i.ID,
			&i.ImageSha256,
			&i.Username,
			&i.StageIndex,
			&i.OptionValue,
			&i.AnnotatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnnotationsByUser = `-- name: GetAnnotationsByUser :many
SELECT a.id, a.image_sha256, a.username, a.stage_index, a.option_value, a.annotated_at, i.filename
FROM annotations a
JOIN images i ON a.image_sha256 = i.sha256
WHERE a.username = ?
ORDER BY a.annotated_at DESC
LIMIT ? OFFSET ?
`

type GetAnnotationsByUserParams struct {
	Username string `json:"username"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type GetAnnotationsByUserRow struct {
	ID          int64      `json:"id"`
	ImageSha256 string     `json:"image_sha256"`
	Username    string     `json:"username"`
	StageIndex  int64      `json:"stage_index"`
	OptionValue string     `json:"option_value"`
	AnnotatedAt *time.Time `json:"annotated_at"`
	Filename    string     `json:"filename"`
}

func (q *Queries) GetAnnotationsByUser(ctx context.Context, arg GetAnnotationsByUserParams) ([]GetAnnotationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAnnotationsByUser, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnnotationsByUserRow{}
	for rows.Next() {
		var i GetAnnotationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ImageSha256,
			&i.Username,
			&i.StageIndex,
			&i.OptionValue,
			&i.AnnotatedAt,
			&i.Filename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnnotationsForImage = `-- name: GetAnnotationsForImage :many
SELECT id, image_sha256, username, stage_index, option_value, annotated_at FROM annotations
WHERE image_sha256 = ?
ORDER BY stage_index ASC
`

func (q *Queries) GetAnnotationsForImage(ctx context.Context, imageSha256 string) ([]Annotation, error) {
	rows, err := q.db.QueryContext(ctx, getAnnotationsForImage, imageSha256)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Annotation{}
	for rows.Next() {
		var i Annotation
		if err := rows.Scan(
			&i.ID,
			&i.ImageSha256,
			&i.Username,
			&i.StageIndex,
			&i.OptionValue,
			&i.AnnotatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnnotationsForStageAndValue = `-- name: GetAnnotationsForStageAndValue :many
SELECT image_sha256, username, annotated_at
FROM annotations
WHERE stage_index = ? AND option_value = ?
ORDER BY image_sha256
`

type GetAnnotationsForStageAndValueParams struct {
	StageIndex  int64  `json:"stage_index"`
	OptionValue string `json:"option_value"`
}

type GetAnnotationsForStageAndValueRow struct {
	ImageSha256 string     `json:"image_sha256"`
	Username    string     `json:"username"`
	AnnotatedAt *time.Time `json:"annotated_at"`
}

func (q *Queries) GetAnnotationsForStageAndValue(ctx context.Context, arg GetAnnotationsForStageAndValueParams) ([]GetAnnotationsForStageAndValueRow, error) {
	rows, err := q.db.QueryContext(ctx, getAnnotationsForStageAndValue, arg.StageIndex, arg.OptionValue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnnotationsForStageAndValueRow{}
	for rows.Next() {
		var i GetAnnotationsForStageAndValueRow
		if err := rows.Scan(&i.ImageSha256, &i.Username, &i.AnnotatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImageHashesWithAnnotation = `-- name: GetImageHashesWithAnnotation :many
SELECT DISTINCT image_sha256
FROM annotations
WHERE stage_index = ? AND option_value = ?
`

type GetImageHashesWithAnnotationParams struct {
	StageIndex  int64  `json:"stage_index"`
	OptionValue string `json:"option_value"`
}

func (q *Queries) GetImageHashesWithAnnotation(ctx context.Context, arg GetImageHashesWithAnnotationParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getImageHashesWithAnnotation, arg.StageIndex, arg.OptionValue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var image_sha256 string
		if err := rows.Scan(&image_sha256); err != nil {
			return nil, err
		}
		items = append(items, image_sha256)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImagesWithoutAnnotationForStage = `-- name: GetImagesWithoutAnnotationForStage :many
SELECT i.sha256, i.filename
FROM images i
WHERE NOT EXISTS (
    SELECT 1 FROM annotations a
    WHERE a.image_sha256 = i.sha256 AND a.stage_index = ?
)
ORDER BY i.filename
`

type GetImagesWithoutAnnotationForStageRow struct {
	Sha256   string `json:"sha256"`
	Filename string `json:"filename"`
}

func (q *Queries) GetImagesWithoutAnnotationForStage(ctx context.Context) ([]GetImagesWithoutAnnotationForStageRow, error) {
	rows, err := q.db.QueryContext(ctx, getImagesWithoutAnnotationForStage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetImagesWithoutAnnotationForStageRow{}
	for rows.Next() {
		var i GetImagesWithoutAnnotationForStageRow
		if err := rows.Scan(&i.Sha256, &i.Filename); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingImagesForUserAndStage = `-- name: ListPendingImagesForUserAndStage :many
WITH annotated_images AS (
  SELECT image_sha256 FROM annotations WHERE username = ? AND stage_index = ?
)
SELECT i.sha256, i.filename, i.ingested_at
FROM images i
LEFT JOIN annotated_images ai ON i.sha256 = ai.image_sha256
WHERE ai.image_sha256 IS NULL
ORDER BY i.filename ASC
LIMIT ?
`

type ListPendingImagesForUserAndStageParams struct {
	Username   string `json:"username"`
	StageIndex int64  `json:"stage_index"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) ListPendingImagesForUserAndStage(ctx context.Context, arg ListPendingImagesForUserAndStageParams) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, listPendingImagesForUserAndStage, arg.Username, arg.StageIndex, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(&i.Sha256, &i.Filename, &i.IngestedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
