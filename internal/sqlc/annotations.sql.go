// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: annotations.sql

package sqlc

import (
	"context"
	"time"
)

const checkAnnotationExists = `-- name: CheckAnnotationExists :one
SELECT EXISTS (
    SELECT 1
    FROM annotations
    WHERE image_id = ? AND username = ? AND stage_index = ?
)
`

type CheckAnnotationExistsParams struct {
	ImageID    int64  `json:"image_id"`
	Username   string `json:"username"`
	StageIndex int64  `json:"stage_index"`
}

func (q *Queries) CheckAnnotationExists(ctx context.Context, arg CheckAnnotationExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkAnnotationExists, arg.ImageID, arg.Username, arg.StageIndex)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countAnnotationsByUser = `-- name: CountAnnotationsByUser :one
SELECT COUNT(*) FROM annotations
WHERE username = ?
`

func (q *Queries) CountAnnotationsByUser(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAnnotationsByUser, username)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAnnotation = `-- name: CreateAnnotation :one
INSERT INTO annotations (image_id, username, stage_index, option_value)
VALUES (?, ?, ?, ?)
ON CONFLICT(image_id, username, stage_index)
DO UPDATE SET
  option_value = excluded.option_value,
  annotated_at = CURRENT_TIMESTAMP
RETURNING id, image_id, username, stage_index, option_value, annotated_at
`

type CreateAnnotationParams struct {
	ImageID     int64  `json:"image_id"`
	Username    string `json:"username"`
	StageIndex  int64  `json:"stage_index"`
	OptionValue string `json:"option_value"`
}

func (q *Queries) CreateAnnotation(ctx context.Context, arg CreateAnnotationParams) (Annotation, error) {
	row := q.db.QueryRowContext(ctx, createAnnotation,
		arg.ImageID,
		arg.Username,
		arg.StageIndex,
		arg.OptionValue,
	)
	var i Annotation
	err := row.Scan(
		&i.ID,
		&i.ImageID,
		&i.Username,
		&i.StageIndex,
		&i.OptionValue,
		&i.AnnotatedAt,
	)
	return i, err
}

const deleteAnnotation = `-- name: DeleteAnnotation :exec
DELETE FROM annotations
WHERE id = ?
`

func (q *Queries) DeleteAnnotation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAnnotation, id)
	return err
}

const deleteAnnotationsForImage = `-- name: DeleteAnnotationsForImage :exec
DELETE FROM annotations
WHERE image_id = ?
`

func (q *Queries) DeleteAnnotationsForImage(ctx context.Context, imageID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAnnotationsForImage, imageID)
	return err
}

const getAnnotation = `-- name: GetAnnotation :one
SELECT id, image_id, username, stage_index, option_value, annotated_at FROM annotations
WHERE image_id = ? AND username = ? AND stage_index = ?
`

type GetAnnotationParams struct {
	ImageID    int64  `json:"image_id"`
	Username   string `json:"username"`
	StageIndex int64  `json:"stage_index"`
}

func (q *Queries) GetAnnotation(ctx context.Context, arg GetAnnotationParams) (Annotation, error) {
	row := q.db.QueryRowContext(ctx, getAnnotation, arg.ImageID, arg.Username, arg.StageIndex)
	var i Annotation
	err := row.Scan(
		&i.ID,
		&i.ImageID,
		&i.Username,
		&i.StageIndex,
		&i.OptionValue,
		&i.AnnotatedAt,
	)
	return i, err
}

const getAnnotationStats = `-- name: GetAnnotationStats :one
SELECT
  COUNT(DISTINCT image_id) as annotated_images,
  COUNT(*) as total_annotations,
  COUNT(DISTINCT username) as total_users
FROM annotations
`

type GetAnnotationStatsRow struct {
	AnnotatedImages  int64 `json:"annotated_images"`
	TotalAnnotations int64 `json:"total_annotations"`
	TotalUsers       int64 `json:"total_users"`
}

func (q *Queries) GetAnnotationStats(ctx context.Context) (GetAnnotationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAnnotationStats)
	var i GetAnnotationStatsRow
	err := row.Scan(&i.AnnotatedImages, &i.TotalAnnotations, &i.TotalUsers)
	return i, err
}

const getAnnotationsByImageAndUser = `-- name: GetAnnotationsByImageAndUser :many
SELECT id, image_id, username, stage_index, option_value, annotated_at FROM annotations
WHERE image_id = ? AND username = ?
ORDER BY stage_index ASC
`

type GetAnnotationsByImageAndUserParams struct {
	ImageID  int64  `json:"image_id"`
	Username string `json:"username"`
}

func (q *Queries) GetAnnotationsByImageAndUser(ctx context.Context, arg GetAnnotationsByImageAndUserParams) ([]Annotation, error) {
	rows, err := q.db.QueryContext(ctx, getAnnotationsByImageAndUser, arg.ImageID, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Annotation{}
	for rows.Next() {
		var i Annotation
		if err := rows.Scan(
			&i.ID,
			&i.ImageID,
			&i.Username,
			&i.StageIndex,
			&i.OptionValue,
			&i.AnnotatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnnotationsByUser = `-- name: GetAnnotationsByUser :many
SELECT a.id, a.image_id, a.username, a.stage_index, a.option_value, a.annotated_at, i.path, i.original_filename
FROM annotations a
JOIN images i ON a.image_id = i.id
WHERE a.username = ?
ORDER BY a.annotated_at DESC
LIMIT ? OFFSET ?
`

type GetAnnotationsByUserParams struct {
	Username string `json:"username"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type GetAnnotationsByUserRow struct {
	ID               int64      `json:"id"`
	ImageID          int64      `json:"image_id"`
	Username         string     `json:"username"`
	StageIndex       int64      `json:"stage_index"`
	OptionValue      string     `json:"option_value"`
	AnnotatedAt      *time.Time `json:"annotated_at"`
	Path             string     `json:"path"`
	OriginalFilename *string    `json:"original_filename"`
}

func (q *Queries) GetAnnotationsByUser(ctx context.Context, arg GetAnnotationsByUserParams) ([]GetAnnotationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAnnotationsByUser, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnnotationsByUserRow{}
	for rows.Next() {
		var i GetAnnotationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ImageID,
			&i.Username,
			&i.StageIndex,
			&i.OptionValue,
			&i.AnnotatedAt,
			&i.Path,
			&i.OriginalFilename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnnotationsForImage = `-- name: GetAnnotationsForImage :many
SELECT id, image_id, username, stage_index, option_value, annotated_at FROM annotations
WHERE image_id = ?
ORDER BY stage_index ASC
`

func (q *Queries) GetAnnotationsForImage(ctx context.Context, imageID int64) ([]Annotation, error) {
	rows, err := q.db.QueryContext(ctx, getAnnotationsForImage, imageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Annotation{}
	for rows.Next() {
		var i Annotation
		if err := rows.Scan(
			&i.ID,
			&i.ImageID,
			&i.Username,
			&i.StageIndex,
			&i.OptionValue,
			&i.AnnotatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingImagesForUserAndStage = `-- name: ListPendingImagesForUserAndStage :many
SELECT i.id, i.path, i.original_filename, i.ingested_at, i.completed_stages, i.is_finished
FROM images i
WHERE i.is_finished = FALSE
  AND NOT EXISTS (
    SELECT 1 FROM annotations a
    WHERE a.image_id = i.id
      AND a.username = ?
      AND a.stage_index = ?
  )
ORDER BY i.completed_stages ASC, i.id ASC
LIMIT ?
`

func (q *Queries) ListPendingImagesForUserAndStage(ctx context.Context, limit int64) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, listPendingImagesForUserAndStage, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.OriginalFilename,
			&i.IngestedAt,
			&i.CompletedStages,
			&i.IsFinished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
